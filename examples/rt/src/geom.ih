#ifndef GEOM_ISPC_H
#define GEOM_ISPC_H

enum GEOM_TYPE {
	SPHERE,
	PLANE
};

struct Geometry {
	GEOM_TYPE type;
	const Material *material;
};

struct Sphere {
	Geometry geom;
	Vec3f center;
	float radius;
};

// An infinite plane centered at some point
struct Plane {
	Geometry geom;
	Vec3f center;
	Vec3f normal;
};

// Allocate and construct a new ISPC-side sphere, the pointer passed will be set to point to
// the newly allocated sphere
export void make_sphere(uniform const Geometry * uniform * uniform out, uniform const Vec3f * uniform center,
		uniform float radius, uniform const Material * uniform mat)
{
	uniform Sphere * uniform sphere = uniform new uniform Sphere;
	sphere->geom.type = SPHERE;
	sphere->geom.material = mat;
	sphere->center = *center;
	sphere->radius = radius;
	*out = (uniform Geometry * uniform)sphere;
}
// Release the ISPC-side sphere
export void drop_sphere(const uniform Geometry * uniform geom){
	uniform Sphere * uniform sphere = (uniform Sphere * uniform)geom;
	delete sphere;
}
inline bool sphere_intersect(Isect &isect, const Ray &ray, const uniform Geometry * uniform geom){
	uniform Sphere * uniform sphere = (uniform Sphere * uniform)geom;
	Vec3f rs = ray.origin - sphere->center;
	const float b = dot(rs, ray.dir);
	const float c = dot(rs, rs) - sphere->radius * sphere->radius;
	const float discrim = b * b - c;
	if (discrim > 0.f){
		float t = -b - sqrt(discrim);
		if (t <= 0.f || t >= isect.t){
			t = -b + sqrt(discrim);
		}
		if (t > 0.f && t < isect.t){
			isect.t = t;
			isect.p = ray.origin + ray.dir * t;
			isect.n = normalize(isect.p - sphere->center);
			return true;
		}
	}
	return false;
}

// Allocate and construct a new ISPC-side plane, the pointer passed will be set to point to
// the newly allocated sphere
export void make_plane(uniform const Geometry * uniform * uniform out, uniform const Vec3f * uniform center,
		uniform const Vec3f * uniform normal, uniform const Material * uniform mat)
{
	uniform Plane * uniform plane = uniform new uniform Plane;
	plane->geom.type = PLANE;
	plane->geom.material = mat;
	plane->center = *center;
	plane->normal = *normal;
	*out = (uniform Geometry * uniform)plane;
}
// Release the ISPC-side sphere
export void drop_plane(const uniform Geometry * uniform geom){
	uniform Plane * uniform plane = (uniform Plane * uniform)geom;
	delete plane;
}
inline bool plane_intersect(Isect &isect, const Ray &ray, const uniform Geometry * uniform geom){
	uniform Plane * uniform plane = (uniform Plane * uniform)geom;
	float t = dot(plane->center - ray.origin, plane->normal) / dot(ray.dir, plane->normal);
	if (t > 0.f && t < isect.t){
		isect.t = t;
		isect.p = ray.origin + ray.dir * t;
		isect.n = plane->normal;
		return true;
	}
	return false;
}

#endif

